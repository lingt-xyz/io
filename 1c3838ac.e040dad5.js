(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{156:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return s}));var r=t(2),a=t(9),o=(t(0),t(274)),i={title:"Method"},c={id:"programming/Go/4_1Method",isDocsHomePage:!1,title:"Method",description:"Go does not have classes. However, you can define methods on types.",source:"@site/docs/programming/Go/4_1Method.mdx",permalink:"/docs/programming/Go/4_1Method",editUrl:"https://github.com/lingt-xyz/io/tree/master/docs/programming/Go/4_1Method.mdx",lastUpdatedAt:1598157283,sidebar:"go",previous:{title:"New or Make",permalink:"/docs/programming/Go/3_11New_Make"},next:{title:"init",permalink:"/docs/programming/Go/4_2init"}},l=[{value:"Method on struct types",id:"method-on-struct-types",children:[]},{value:"Methods are functions",id:"methods-are-functions",children:[]},{value:"Method on non-struct types",id:"method-on-non-struct-types",children:[]},{value:"Pointer receivers",id:"pointer-receivers",children:[]},{value:"Pointers and functions",id:"pointers-and-functions",children:[]}],p={rightToc:l};function s(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Go does not have classes. However, you can define methods on types."),Object(o.b)("p",null,"A method is a function with a special receiver argument."),Object(o.b)("p",null,"The receiver appears in its own argument list between the ",Object(o.b)("inlineCode",{parentName:"p"},"func")," keyword and the method name."),Object(o.b)("h2",{id:"method-on-struct-types"},"Method on struct types"),Object(o.b)("p",null,"In this example, the ",Object(o.b)("inlineCode",{parentName:"p"},"Abs")," method has a receiver of type ",Object(o.b)("inlineCode",{parentName:"p"},"Vertex")," named ",Object(o.b)("inlineCode",{parentName:"p"},"v"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n}\n')),Object(o.b)("h2",{id:"methods-are-functions"},"Methods are functions"),Object(o.b)("p",null,"Remember: a method is just a function with a receiver argument."),Object(o.b)("p",null,"Here's ",Object(o.b)("inlineCode",{parentName:"p"},"Abs")," written as a regular function with no change in functionality."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(Abs(v))\n}\n\n')),Object(o.b)("h2",{id:"method-on-non-struct-types"},"Method on non-struct types"),Object(o.b)("p",null,"In this example we see a numeric type ",Object(o.b)("inlineCode",{parentName:"p"},"MyFloat")," with an ",Object(o.b)("inlineCode",{parentName:"p"},"Abs")," method."),Object(o.b)("p",null,"You can only declare a method with a receiver whose type is defined in the same package as the method. You cannot declare a method with a receiver whose type is defined in another package ","(","which includes the built-in types such as ",Object(o.b)("inlineCode",{parentName:"p"},"int"),")","."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n    if f < 0 {\n        return float64(-f)\n    }\n    return float64(f)\n}\n\nfunc main() {\n    f := MyFloat(-math.Sqrt2)\n    fmt.Println(f.Abs())\n}\n')),Object(o.b)("h2",{id:"pointer-receivers"},"Pointer receivers"),Object(o.b)("p",null,"You can declare methods with pointer receivers."),Object(o.b)("p",null,"This means the receiver type has the literal syntax ",Object(o.b)("inlineCode",{parentName:"p"},"*T")," for some type ",Object(o.b)("inlineCode",{parentName:"p"},"T"),". ","(","Also, ",Object(o.b)("inlineCode",{parentName:"p"},"T")," cannot itself be a pointer such as ",Object(o.b)("inlineCode",{parentName:"p"},"*int"),".",")"),Object(o.b)("p",null,"For example, the ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," method here is defined on ",Object(o.b)("inlineCode",{parentName:"p"},"*Vertex"),"."),Object(o.b)("p",null,"Methods with pointer receivers can modify the value to which the receiver points ","(","as ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," does here",")",". Since methods often need to modify their receiver, pointer receivers are more common than value receivers."),Object(o.b)("p",null,"Try removing the ",Object(o.b)("inlineCode",{parentName:"p"},"*")," from the declaration of the ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," function on line 16 and observe how the program's behavior changes."),Object(o.b)("p",null,"With a value receiver, the ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," method operates on ",Object(o.b)("strong",{parentName:"p"},"a copy of the original ",Object(o.b)("inlineCode",{parentName:"strong"},"Vertex")," value"),". ","(","This is the same behavior as for any other function argument.",")"," The ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," method must have a pointer receiver to change the ",Object(o.b)("inlineCode",{parentName:"p"},"Vertex")," value declared in the ",Object(o.b)("inlineCode",{parentName:"p"},"main")," function."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(10)\n    fmt.Println(v.Abs())\n}\n\n\n// 50\n')),Object(o.b)("h2",{id:"pointers-and-functions"},"Pointers and functions"),Object(o.b)("p",null,"Here we see the ",Object(o.b)("inlineCode",{parentName:"p"},"Abs")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," methods rewritten as functions."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc Scale(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    Scale(&v, 10)\n    fmt.Println(Abs(v))\n}\n')),Object(o.b)("p",null,"Comparing the previous two programs, you might notice that ",Object(o.b)("strong",{parentName:"p"},"functions with a pointer argument")," must take a pointer:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-text"}),"var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n")),Object(o.b)("p",null,"while ",Object(o.b)("strong",{parentName:"p"},"methods with pointer receivers")," take either a value or a pointer as the receiver when they are called:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-text"}),"var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n")),Object(o.b)("p",null,"For the statement ",Object(o.b)("inlineCode",{parentName:"p"},"v.Scale(5)"),", even though ",Object(o.b)("inlineCode",{parentName:"p"},"v")," is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement ",Object(o.b)("inlineCode",{parentName:"p"},"v.Scale(5)")," as ",Object(o.b)("inlineCode",{parentName:"p"},"(&v).Scale(5)")," since the ",Object(o.b)("inlineCode",{parentName:"p"},"Scale")," method has a pointer receiver."),Object(o.b)("p",null,"The equivalent thing happens in the reverse direction."),Object(o.b)("p",null,"Functions that take a value argument must take a value of that specific type:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-text"}),"var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n")),Object(o.b)("p",null,"while methods with value receivers take either a value or a pointer as the receiver when they are called:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-text"}),"var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n")))}s.isMDXComponent=!0},274:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return d}));var r=t(0),a=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=a.a.createContext({}),s=function(e){var n=a.a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},b=function(e){var n=s(e.components);return a.a.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),b=s(t),u=r,d=b["".concat(i,".").concat(u)]||b[u]||m[u]||o;return t?a.a.createElement(d,c(c({ref:n},p),{},{components:t})):a.a.createElement(d,c({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var p=2;p<o;p++)i[p]=t[p];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);